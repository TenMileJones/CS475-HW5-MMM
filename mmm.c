#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include "mmm.h"

/**
 * Allocate and initialize the matrices on the heap. Populate
 * the input matrices with random numbers from 0 to 99
 */
void mmm_init() {
	// Allocate matrices
	A = (double**) malloc(size * sizeof(double*));
	B = (double**) malloc(size * sizeof(double*));
	SEQ_MATRIX = (double**) malloc(size * sizeof(double*));
	PAR_MATRIX = (double**) malloc(size * sizeof(double*));
	
	srand((unsigned)time(NULL));	// seed the random number generator
 	// initialize A and B with random values between 0 and 99
	// initialize SEQ_MATRIX and PAR_MATRIX with 0s
	for (int i = 0; i < size; i++){
		A[i] = (double*) malloc(size * sizeof(double));
		B[i] = (double*) malloc(size * sizeof(double));
		SEQ_MATRIX[i] = (double*) malloc(size * sizeof(double));
		PAR_MATRIX[i] = (double*) malloc(size * sizeof(double));

		for (int j = 0; j < size; j++){
			A[i][j] = rand() % 100;
			B[i][j] = rand() % 100;
			SEQ_MATRIX[i][j] = 0;
			PAR_MATRIX[i][j] = 0;
		}
	}
}

/**
 * Reset a given matrix to zeroes (their size is in the global var)
 * @param matrix pointer to a 2D array
 */
void mmm_reset(double **matrix) {
	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
			matrix[i][j] = 0;
		}		
	}
}

/**
 * Free up memory allocated to all matrices
 * (their size is in the global var)
 */
void mmm_freeup() {
	
    for (int i = 0; i < size; i++) {
		free(A[i]);
		free(B[i]);
		free(SEQ_MATRIX[i]);
		free(PAR_MATRIX[i]);
	}
    free(A);
	free(B);
	free(SEQ_MATRIX);
	free(PAR_MATRIX);
}

/**
 * Sequential MMM (size is in the global var)
 */
void mmm_seq() {
	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
			SEQ_MATRIX[i][j] = mmm_cell(i, j);
		}		
	}
}

/**
 * Calculates value of cell at i, j
*/
double mmm_cell(int i, int j) {
	double answer = 0;
	for (int count = 0; count < size; count++) {
		answer += (A[i][count] * B[count][j]);
	}
	return answer;
}

/**
 * Parallel MMM
 */
void* mmm_par(void *args) {
	// cast args
	thread_args *params = (thread_args*) args;

	// start must be first row thread works on, 
	//  end must be the row the next thread starts on
	for (int i = params->start; i < params->end; i++) {
		for (int j = 0; j < size; j++) {
			PAR_MATRIX[i][j] = mmm_cell(i, j);
		}		
	}

	return NULL;
}

/**
 * Verifies the correctness between the matrices generated by
 * the sequential run and the parallel run.
 *
 * @return the largest error between two corresponding elements
 * in the result matrices
 */
double mmm_verify() {
	double largestError = 0;
	double errorBeingChecked;

	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
			errorBeingChecked = fabs(PAR_MATRIX[i][j] - SEQ_MATRIX[i][j]);
			
			if(errorBeingChecked > largestError){
				largestError = errorBeingChecked;
			}
		}		
	}
	return largestError;
}
